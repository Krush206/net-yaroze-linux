/* OBSOLETE /* Definitions to make GDB run on Convex Unix (4bsd) */
/* OBSOLETE    Copyright 1989, 1991, 1993 Free Software Foundation, Inc. */
/* OBSOLETE  */
/* OBSOLETE This file is part of GDB. */
/* OBSOLETE  */
/* OBSOLETE This program is free software; you can redistribute it and/or modify */
/* OBSOLETE it under the terms of the GNU General Public License as published by */
/* OBSOLETE the Free Software Foundation; either version 2 of the License, or */
/* OBSOLETE (at your option) any later version. */
/* OBSOLETE  */
/* OBSOLETE This program is distributed in the hope that it will be useful, */
/* OBSOLETE but WITHOUT ANY WARRANTY; without even the implied warranty of */
/* OBSOLETE MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
/* OBSOLETE GNU General Public License for more details. */
/* OBSOLETE  */
/* OBSOLETE You should have received a copy of the GNU General Public License */
/* OBSOLETE along with this program; if not, write to the Free Software */
/* OBSOLETE Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #define TARGET_BYTE_ORDER BIG_ENDIAN */
/* OBSOLETE  */
/* OBSOLETE /* There is come problem with the debugging symbols generated by the */
/* OBSOLETE    compiler such that the debugging symbol for the first line of a */
/* OBSOLETE    function overlap with the function prologue.  *x/ */
/* OBSOLETE #define PROLOGUE_FIRSTLINE_OVERLAP */
/* OBSOLETE  */
/* OBSOLETE /* When convex pcc says CHAR or SHORT, it provides the correct address.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #define BELIEVE_PCC_PROMOTION 1 */
/* OBSOLETE  */
/* OBSOLETE /* Symbol types to ignore.  *x/ */
/* OBSOLETE /* 0xc4 is N_MONPT.  Use the numeric value for the benefit of people */
/* OBSOLETE    with (rather) old OS's.  *x/ */
/* OBSOLETE #define IGNORE_SYMBOL(TYPE) \ */
/* OBSOLETE     (((TYPE) & ~N_EXT) == N_TBSS       \ */
/* OBSOLETE      || ((TYPE) & ~N_EXT) == N_TDATA   \ */
/* OBSOLETE      || ((TYPE) & ~N_EXT) == 0xc4) */
/* OBSOLETE  */
/* OBSOLETE /* Offset from address of function to start of its code. */
/* OBSOLETE    Zero on most machines.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #define FUNCTION_START_OFFSET 0 */
/* OBSOLETE  */
/* OBSOLETE /* Advance PC across any function entry prologue instructions */
/* OBSOLETE    to reach some "real" code. */
/* OBSOLETE    Convex prolog is: */
/* OBSOLETE        [sub.w #-,sp]                in one of 3 possible sizes */
/* OBSOLETE        [mov psw,-           fc/vc main program prolog */
/* OBSOLETE         and #-,-              (skip it because the "mov psw" saves the */
/* OBSOLETE     mov -,psw]                 T bit, so continue gets a surprise trap) */
/* OBSOLETE        [and #-,sp]          fc/vc O2 main program prolog */
/* OBSOLETE        [ld.- -(ap),-]               pcc/gcc register arg loads */
/* OBSOLETE *x/ */
/* OBSOLETE  */
/* OBSOLETE extern CORE_ADDR convex_skip_prologue PARAMS ((CORE_ADDR pc)); */
/* OBSOLETE #define SKIP_PROLOGUE(pc) (convex_skip_prologue (pc)) */
/* OBSOLETE  */
/* OBSOLETE /* Immediately after a function call, return the saved pc. */
/* OBSOLETE    (ignore frame and return *$sp so we can handle both calls and callq) *x/ */
/* OBSOLETE  */
/* OBSOLETE #define SAVED_PC_AFTER_CALL(frame) \ */
/* OBSOLETE     read_memory_integer (read_register (SP_REGNUM), 4) */
/* OBSOLETE  */
/* OBSOLETE /* Address of end of stack space. */
/* OBSOLETE    This is ((USRSTACK + 0xfff) & -0x1000)) from <convex/vmparam.h> but */
/* OBSOLETE    that expression depends on the kernel version; instead, fetch a */
/* OBSOLETE    page-zero pointer and get it from that.  This will be invalid if */
/* OBSOLETE    they ever change the way bkpt signals are delivered.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #define STACK_END_ADDR (0xfffff000 & *(unsigned *) 0x80000050) */
/* OBSOLETE  */
/* OBSOLETE /* User-mode traps push an extended rtn block, */
/* OBSOLETE    then fault with one of the following PCs *x/ */
/* OBSOLETE  */
/* OBSOLETE #define is_trace_pc(pc)  ((unsigned) ((pc) - (*(int *) 0x80000040)) <= 4) */
/* OBSOLETE #define is_arith_pc(pc)  ((unsigned) ((pc) - (*(int *) 0x80000044)) <= 4) */
/* OBSOLETE #define is_break_pc(pc)  ((unsigned) ((pc) - (*(int *) 0x80000050)) <= 4) */
/* OBSOLETE  */
/* OBSOLETE /* We need to manipulate trap bits in the psw *x/ */
/* OBSOLETE  */
/* OBSOLETE #define PSW_TRAP_FLAGS      0x69670000 */
/* OBSOLETE #define PSW_T_BIT   0x08000000 */
/* OBSOLETE #define PSW_S_BIT   0x01000000 */
/* OBSOLETE  */
/* OBSOLETE /* Stack grows downward.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #define INNER_THAN(lhs,rhs) ((lhs) < (rhs)) */
/* OBSOLETE  */
/* OBSOLETE /* Sequence of bytes for breakpoint instruction. (bkpt)  *x/ */
/* OBSOLETE  */
/* OBSOLETE #define BREAKPOINT {0x7d,0x50} */
/* OBSOLETE  */
/* OBSOLETE /* Amount PC must be decremented by after a breakpoint. */
/* OBSOLETE    This is often the number of bytes in BREAKPOINT but not always. */
/* OBSOLETE    (The break PC needs to be decremented by 2, but we do it when the */
/* OBSOLETE    break frame is recognized and popped.  That way gdb can tell breaks */
/* OBSOLETE    from trace traps with certainty.) *x/ */
/* OBSOLETE  */
/* OBSOLETE #define DECR_PC_AFTER_BREAK 0 */
/* OBSOLETE  */
/* OBSOLETE /* Say how long (ordinary) registers are.  This is a piece of bogosity */
/* OBSOLETE    used in push_word and a few other places; REGISTER_RAW_SIZE is the */
/* OBSOLETE    real way to know how big a register is.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #define REGISTER_SIZE 8 */
/* OBSOLETE  */
/* OBSOLETE /* Number of machine registers *x/ */
/* OBSOLETE  */
/* OBSOLETE #define NUM_REGS 26 */
/* OBSOLETE  */
/* OBSOLETE /* Initializer for an array of names of registers. */
/* OBSOLETE    There should be NUM_REGS strings in this initializer.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #define REGISTER_NAMES {"pc","psw","fp","ap","a5","a4","a3","a2","a1","sp",\ */
/* OBSOLETE                     "s7","s6","s5","s4","s3","s2","s1","s0",\ */
/* OBSOLETE                     "S7","S6","S5","S4","S3","S2","S1","S0"} */
/* OBSOLETE  */
/* OBSOLETE /* Register numbers of various important registers. */
/* OBSOLETE    Note that some of these values are "real" register numbers, */
/* OBSOLETE    and correspond to the general registers of the machine, */
/* OBSOLETE    and some are "phony" register numbers which are too large */
/* OBSOLETE    to be actual register numbers as far as the user is concerned */
/* OBSOLETE    but do serve to get the desired values when passed to read_register.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #define S0_REGNUM 25                /* the real S regs *x/ */
/* OBSOLETE #define S7_REGNUM 18 */
/* OBSOLETE #define s0_REGNUM 17                /* low-order halves of S regs *x/ */
/* OBSOLETE #define s7_REGNUM 10 */
/* OBSOLETE #define SP_REGNUM 9                 /* A regs *x/ */
/* OBSOLETE #define A1_REGNUM 8 */
/* OBSOLETE #define A5_REGNUM 4 */
/* OBSOLETE #define AP_REGNUM 3 */
/* OBSOLETE #define FP_REGNUM 2         /* Contains address of executing stack frame *x/ */
/* OBSOLETE #define PS_REGNUM 1         /* Contains processor status *x/ */
/* OBSOLETE #define PC_REGNUM 0         /* Contains program counter *x/ */
/* OBSOLETE  */
/* OBSOLETE /* convert dbx stab register number (from `r' declaration) to a gdb REGNUM *x/ */
/* OBSOLETE  */
/* OBSOLETE #define STAB_REG_TO_REGNUM(value) \ */
/* OBSOLETE       ((value) < 8 ? S0_REGNUM - (value) : SP_REGNUM - ((value) - 8)) */
/* OBSOLETE  */
/* OBSOLETE /* Vector register numbers, not handled as ordinary regs. */
/* OBSOLETE    They are treated as convenience variables whose values are read */
/* OBSOLETE    from the inferior when needed.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #define V0_REGNUM 0 */
/* OBSOLETE #define V7_REGNUM 7 */
/* OBSOLETE #define VM_REGNUM 8 */
/* OBSOLETE #define VS_REGNUM 9 */
/* OBSOLETE #define VL_REGNUM 10 */
/* OBSOLETE  */
/* OBSOLETE /* Total amount of space needed to store our copies of the machine's */
/* OBSOLETE    register state, the array `registers'.  *x/ */
/* OBSOLETE #define REGISTER_BYTES (4*10 + 8*8) */
/* OBSOLETE  */
/* OBSOLETE /* Index within `registers' of the first byte of the space for */
/* OBSOLETE    register N. */
/* OBSOLETE    NB: must match structure of struct syscall_context for correct operation *x/ */
/* OBSOLETE  */
/* OBSOLETE #define REGISTER_BYTE(N) ((N) < s7_REGNUM ? 4*(N) : \ */
/* OBSOLETE                       (N) < S7_REGNUM ? 44 + 8 * ((N)-s7_REGNUM) : \ */
/* OBSOLETE                                         40 + 8 * ((N)-S7_REGNUM)) */
/* OBSOLETE  */
/* OBSOLETE /* Number of bytes of storage in the actual machine representation */
/* OBSOLETE    for register N. *x/ */
/* OBSOLETE  */
/* OBSOLETE #define REGISTER_RAW_SIZE(N) ((N) < S7_REGNUM ? 4 : 8) */
/* OBSOLETE  */
/* OBSOLETE /* Number of bytes of storage in the program's representation */
/* OBSOLETE    for register N.   *x/ */
/* OBSOLETE  */
/* OBSOLETE #define REGISTER_VIRTUAL_SIZE(N) REGISTER_RAW_SIZE(N) */
/* OBSOLETE  */
/* OBSOLETE /* Largest value REGISTER_RAW_SIZE can have.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #define MAX_REGISTER_RAW_SIZE 8 */
/* OBSOLETE  */
/* OBSOLETE /* Largest value REGISTER_VIRTUAL_SIZE can have.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #define MAX_REGISTER_VIRTUAL_SIZE 8 */
/* OBSOLETE  */
/* OBSOLETE /* Return the GDB type object for the "standard" data type */
/* OBSOLETE    of data in register N.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #define REGISTER_VIRTUAL_TYPE(N) \ */
/* OBSOLETE    ((N) < S7_REGNUM ? builtin_type_int : builtin_type_long_long) */
/* OBSOLETE  */
/* OBSOLETE /* Store the address of the place in which to copy the structure the */
/* OBSOLETE    subroutine will return.  This is called from call_function. *x/ */
/* OBSOLETE  */
/* OBSOLETE #define STORE_STRUCT_RETURN(ADDR, SP) \ */
/* OBSOLETE   { write_register (A1_REGNUM, (ADDR)); } */
/* OBSOLETE  */
/* OBSOLETE /* Extract from an array REGBUF containing the (raw) register state */
/* OBSOLETE    a function return value of type TYPE, and copy that, in virtual format, */
/* OBSOLETE    into VALBUF.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #define EXTRACT_RETURN_VALUE(TYPE,REGBUF,VALBUF) \ */
/* OBSOLETE   memcpy (VALBUF, &((char *) REGBUF) [REGISTER_BYTE (S0_REGNUM) + \ */
/* OBSOLETE                          8 - TYPE_LENGTH (TYPE)],\ */
/* OBSOLETE      TYPE_LENGTH (TYPE)) */
/* OBSOLETE  */
/* OBSOLETE /* Write into appropriate registers a function return value */
/* OBSOLETE    of type TYPE, given in virtual format.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #define STORE_RETURN_VALUE(TYPE,VALBUF) \ */
/* OBSOLETE     write_register_bytes (REGISTER_BYTE (S0_REGNUM), VALBUF, 8) */
/* OBSOLETE  */
/* OBSOLETE /* Extract from an array REGBUF containing the (raw) register state */
/* OBSOLETE    the address in which a function should return its structure value, */
/* OBSOLETE    as a CORE_ADDR (or an expression that can be used as one).  *x/ */
/* OBSOLETE  */
/* OBSOLETE #define EXTRACT_STRUCT_VALUE_ADDRESS(REGBUF) \ */
/* OBSOLETE     (*(int *) & ((char *) REGBUF) [REGISTER_BYTE (s0_REGNUM)]) */
/* OBSOLETE  */
/* OBSOLETE /* Define trapped internal variable hooks to read and write */
/* OBSOLETE    vector and communication registers.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #define IS_TRAPPED_INTERNALVAR is_trapped_internalvar */
/* OBSOLETE #define VALUE_OF_TRAPPED_INTERNALVAR value_of_trapped_internalvar */
/* OBSOLETE #define SET_TRAPPED_INTERNALVAR set_trapped_internalvar */
/* OBSOLETE  */
/* OBSOLETE extern struct value *value_of_trapped_internalvar (); */
/* OBSOLETE  */
/* OBSOLETE /* Hooks to read data from soff exec and core files, */
/* OBSOLETE    and to describe the files.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #define FILES_INFO_HOOK print_maps */
/* OBSOLETE  */
/* OBSOLETE /* Hook to call to print a typeless integer value, normally printed in decimal. */
/* OBSOLETE    For convex, use hex instead if the number looks like an address.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #define PRINT_TYPELESS_INTEGER decout */
/* OBSOLETE  */
/* OBSOLETE /* For the native compiler, variables for a particular lexical context */
/* OBSOLETE    are listed after the beginning LBRAC instead of before in the */
/* OBSOLETE    executables list of symbols.  Using "gcc_compiled." to distinguish */
/* OBSOLETE    between GCC and native compiler doesn't work on Convex because the */
/* OBSOLETE    linker sorts the symbols to put "gcc_compiled." in the wrong place. */
/* OBSOLETE    desc is nonzero for native, zero for gcc.   *x/ */
/* OBSOLETE #define VARIABLES_INSIDE_BLOCK(desc, gcc_p) (desc != 0) */
/* OBSOLETE  */
/* OBSOLETE /* Pcc occaisionally puts an SO where there should be an SOL.   *x/ */
/* OBSOLETE #define PCC_SOL_BROKEN */
/* OBSOLETE  */
/* OBSOLETE /* Describe the pointer in each stack frame to the previous stack frame */
/* OBSOLETE    (its caller).  *x/ */
/* OBSOLETE  */
/* OBSOLETE /* FRAME_CHAIN takes a frame_info with a frame's nominal address in fi->frame, */
/* OBSOLETE    and produces the frame's chain-pointer. *x/ */
/* OBSOLETE  */
/* OBSOLETE /* (caller fp is saved at 8(fp)) *x/ */
/* OBSOLETE  */
/* OBSOLETE #define FRAME_CHAIN(fi)   (read_memory_integer ((fi)->frame + 8, 4)) */
/* OBSOLETE  */
/* OBSOLETE /* Define other aspects of the stack frame.  *x/ */
/* OBSOLETE  */
/* OBSOLETE /* We need the boundaries of the text in the exec file, as a kludge, */
/* OBSOLETE    for FRAMELESS_FUNCTION_INVOCATION and CALL_DUMMY_LOCATION. *x/ */
/* OBSOLETE  */
/* OBSOLETE #define     NEED_TEXT_START_END 1 */
/* OBSOLETE  */
/* OBSOLETE /* An expression that tells us whether the function invocation represented */
/* OBSOLETE    by FI does not have a frame on the stack associated with it. */
/* OBSOLETE    On convex, check at the return address for `callq' -- if so, frameless, */
/* OBSOLETE    otherwise, not.  *x/ */
/* OBSOLETE  */
/* OBSOLETE extern int convex_frameless_function_invocation PARAMS ((struct frame_info *fi)); */
/* OBSOLETE #define FRAMELESS_FUNCTION_INVOCATION(FI) (convex_frameless_function_invocatio (FI)) */
/* OBSOLETE  */
/* OBSOLETE #define FRAME_SAVED_PC(fi) (read_memory_integer ((fi)->frame, 4)) */
/* OBSOLETE  */
/* OBSOLETE #define FRAME_ARGS_ADDRESS(fi) (read_memory_integer ((fi)->frame + 12, 4)) */
/* OBSOLETE  */
/* OBSOLETE #define FRAME_LOCALS_ADDRESS(fi) (fi)->frame */
/* OBSOLETE  */
/* OBSOLETE /* Return number of args passed to a frame. */
/* OBSOLETE    Can return -1, meaning no way to tell.  *x/ */
/* OBSOLETE  */
/* OBSOLETE extern int convex_frame_num_args PARAMS ((struct frame_info *fi)); */
/* OBSOLETE #define FRAME_NUM_ARGS(fi) (convex_frame_num_args ((fi))) */
/* OBSOLETE  */
/* OBSOLETE /* Return number of bytes at start of arglist that are not really args.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #define FRAME_ARGS_SKIP 0 */
/* OBSOLETE  */
/* OBSOLETE /* Put here the code to store, into a struct frame_saved_regs, */
/* OBSOLETE    the addresses of the saved registers of frame described by FRAME_INFO. */
/* OBSOLETE    This includes special registers such as pc and fp saved in special */
/* OBSOLETE    ways in the stack frame.  sp is even more special: */
/* OBSOLETE    the address we return for it IS the sp for the next frame.  *x/ */
/* OBSOLETE  */
/* OBSOLETE /* Normal (short) frames save only PC, FP, (callee's) AP.  To reasonably */
/* OBSOLETE    handle gcc and pcc register variables, scan the code following the */
/* OBSOLETE    call for the instructions the compiler inserts to reload register */
/* OBSOLETE    variables from stack slots and record the stack slots as the saved */
/* OBSOLETE    locations of those registers.  This will occasionally identify some */
/* OBSOLETE    random load as a saved register; this is harmless.  vc does not */
/* OBSOLETE    declare its register allocation actions in the stabs.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #define FRAME_FIND_SAVED_REGS(frame_info, frame_saved_regs)         \ */
/* OBSOLETE { register int regnum;                                                      \ */
/* OBSOLETE   register int frame_length =       /* 3 short, 2 long, 1 extended, 0 context *x/\ */
/* OBSOLETE       (read_memory_integer ((frame_info)->frame + 4, 4) >> 25) & 3; \ */
/* OBSOLETE   register CORE_ADDR frame_fp =                                             \ */
/* OBSOLETE       read_memory_integer ((frame_info)->frame + 8, 4);                     \ */
/* OBSOLETE   register CORE_ADDR next_addr;                                             \ */
/* OBSOLETE   memset (&frame_saved_regs, '\0', sizeof frame_saved_regs);                        \ */
/* OBSOLETE   (frame_saved_regs).regs[PC_REGNUM] = (frame_info)->frame + 0;             \ */
/* OBSOLETE   (frame_saved_regs).regs[PS_REGNUM] = (frame_info)->frame + 4;             \ */
/* OBSOLETE   (frame_saved_regs).regs[FP_REGNUM] = (frame_info)->frame + 8;             \ */
/* OBSOLETE   (frame_saved_regs).regs[AP_REGNUM] = frame_fp + 12;                       \ */
/* OBSOLETE   next_addr = (frame_info)->frame + 12;                                     \ */
/* OBSOLETE   if (frame_length < 3)                                                     \ */
/* OBSOLETE     for (regnum = A5_REGNUM; regnum < SP_REGNUM; ++regnum)          \ */
/* OBSOLETE       (frame_saved_regs).regs[regnum] = (next_addr += 4);           \ */
/* OBSOLETE   if (frame_length < 2)                                                     \ */
/* OBSOLETE     (frame_saved_regs).regs[SP_REGNUM] = (next_addr += 4);          \ */
/* OBSOLETE   next_addr -= 4;                                                   \ */
/* OBSOLETE   if (frame_length < 3)                                                     \ */
/* OBSOLETE     for (regnum = S7_REGNUM; regnum < S0_REGNUM; ++regnum)          \ */
/* OBSOLETE       (frame_saved_regs).regs[regnum] = (next_addr += 8);           \ */
/* OBSOLETE   if (frame_length < 2)                                                     \ */
/* OBSOLETE     (frame_saved_regs).regs[S0_REGNUM] = (next_addr += 8);          \ */
/* OBSOLETE   else                                                                      \ */
/* OBSOLETE     (frame_saved_regs).regs[SP_REGNUM] = next_addr + 8;                     \ */
/* OBSOLETE   if (frame_length == 3) {                                          \ */
/* OBSOLETE     CORE_ADDR pc = read_memory_integer ((frame_info)->frame, 4);    \ */
/* OBSOLETE     int op, ix, disp;                                                       \ */
/* OBSOLETE     op = read_memory_integer (pc, 2);                                       \ */
/* OBSOLETE     if ((op & 0xffc7) == 0x1480) pc += 4;   /* add.w #-,sp *x/      \ */
/* OBSOLETE     else if ((op & 0xffc7) == 0x58c0) pc += 2;      /* add.w #-,sp *x/      \ */
/* OBSOLETE     op = read_memory_integer (pc, 2);                                       \ */
/* OBSOLETE     if ((op & 0xffc7) == 0x2a06) pc += 4;   /* ld.w -,ap *x/                \ */
/* OBSOLETE     for (;;) {                                                              \ */
/* OBSOLETE       op = read_memory_integer (pc, 2);                                     \ */
/* OBSOLETE       ix = (op >> 3) & 7;                                           \ */
/* OBSOLETE       if ((op & 0xfcc0) == 0x2800) {                /* ld.- -,ak *x/                \ */
/* OBSOLETE         regnum = SP_REGNUM - (op & 7);                                      \ */
/* OBSOLETE     disp = read_memory_integer (pc + 2, 2);                         \ */
/* OBSOLETE     pc += 4;}                                                       \ */
/* OBSOLETE       else if ((op & 0xfcc0) == 0x2840) {   /* ld.- -,ak *x/                \ */
/* OBSOLETE         regnum = SP_REGNUM - (op & 7);                                      \ */
/* OBSOLETE     disp = read_memory_integer (pc + 2, 4);                         \ */
/* OBSOLETE     pc += 6;}                                                       \ */
/* OBSOLETE       if ((op & 0xfcc0) == 0x3000) {                /* ld.- -,sk *x/                \ */
/* OBSOLETE         regnum = S0_REGNUM - (op & 7);                                      \ */
/* OBSOLETE     disp = read_memory_integer (pc + 2, 2);                         \ */
/* OBSOLETE     pc += 4;}                                                       \ */
/* OBSOLETE       else if ((op & 0xfcc0) == 0x3040) {   /* ld.- -,sk *x/                \ */
/* OBSOLETE         regnum = S0_REGNUM - (op & 7);                                      \ */
/* OBSOLETE     disp = read_memory_integer (pc + 2, 4);                         \ */
/* OBSOLETE     pc += 6;}                                                       \ */
/* OBSOLETE       else if ((op & 0xff00) == 0x7100) {   /* br crossjump *x/     \ */
/* OBSOLETE         pc += 2 * (char) op;                                                \ */
/* OBSOLETE         continue;}                                                  \ */
/* OBSOLETE       else if (op == 0x0140) {                      /* jmp crossjump *x/    \ */
/* OBSOLETE         pc = read_memory_integer (pc + 2, 4);                               \ */
/* OBSOLETE         continue;}                                                  \ */
/* OBSOLETE       else break;                                                   \ */
/* OBSOLETE       if ((frame_saved_regs).regs[regnum])                          \ */
/* OBSOLETE     break;                                                          \ */
/* OBSOLETE       if (ix == 7) disp += frame_fp;                                        \ */
/* OBSOLETE       else if (ix == 6) disp += read_memory_integer (frame_fp + 12, 4);     \ */
/* OBSOLETE       else if (ix != 0) break;                                              \ */
/* OBSOLETE       (frame_saved_regs).regs[regnum] =                                     \ */
/* OBSOLETE     disp - 8 + (1 << ((op >> 8) & 3));                              \ */
/* OBSOLETE       if (regnum >= S7_REGNUM)                                              \ */
/* OBSOLETE         (frame_saved_regs).regs[regnum - S0_REGNUM + s0_REGNUM] =   \ */
/* OBSOLETE       disp - 4 + (1 << ((op >> 8) & 3));                            \ */
/* OBSOLETE     }                                                                       \ */
/* OBSOLETE   }                                                                 \ */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Things needed for making the inferior call functions.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #define     CALL_DUMMY_LOCATION     BEFORE_TEXT_END */
/* OBSOLETE  */
/* OBSOLETE /* Push an empty stack frame, to record the current PC, etc.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #define PUSH_DUMMY_FRAME \ */
/* OBSOLETE { register CORE_ADDR sp = read_register (SP_REGNUM);                        \ */
/* OBSOLETE   register int regnum;                                                      \ */
/* OBSOLETE   char buf[8];                                                              \ */
/* OBSOLETE   long word;                                                                \ */
/* OBSOLETE   for (regnum = S0_REGNUM; regnum >= S7_REGNUM; --regnum) {                 \ */
/* OBSOLETE     read_register_bytes (REGISTER_BYTE (regnum), buf, 8);           \ */
/* OBSOLETE     sp = push_bytes (sp, buf, 8);}                                  \ */
/* OBSOLETE   for (regnum = SP_REGNUM; regnum >= FP_REGNUM; --regnum) {                 \ */
/* OBSOLETE     word = read_register (regnum);                                  \ */
/* OBSOLETE     sp = push_bytes (sp, &word, 4);}                                        \ */
/* OBSOLETE   word = (read_register (PS_REGNUM) &~ (3<<25)) | (1<<25);          \ */
/* OBSOLETE   sp = push_bytes (sp, &word, 4);                                   \ */
/* OBSOLETE   word = read_register (PC_REGNUM);                                 \ */
/* OBSOLETE   sp = push_bytes (sp, &word, 4);                                           \ */
/* OBSOLETE   write_register (SP_REGNUM, sp);                                   \ */
/* OBSOLETE   write_register (FP_REGNUM, sp);                                   \ */
/* OBSOLETE   write_register (AP_REGNUM, sp);} */
/* OBSOLETE  */
/* OBSOLETE /* Discard from the stack the innermost frame, restoring all registers.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #define POP_FRAME  do {\ */
/* OBSOLETE   register CORE_ADDR fp = read_register (FP_REGNUM);            \ */
/* OBSOLETE   register int regnum;                                          \ */
/* OBSOLETE   register int frame_length =       /* 3 short, 2 long, 1 extended, 0 context *x/ \ */
/* OBSOLETE       (read_memory_integer (fp + 4, 4) >> 25) & 3;          \ */
/* OBSOLETE   char buf[8];                                                  \ */
/* OBSOLETE   write_register (PC_REGNUM, read_memory_integer (fp, 4));  \ */
/* OBSOLETE   write_register (PS_REGNUM, read_memory_integer (fp += 4, 4));  \ */
/* OBSOLETE   write_register (FP_REGNUM, read_memory_integer (fp += 4, 4));  \ */
/* OBSOLETE   write_register (AP_REGNUM, read_memory_integer (fp += 4, 4));  \ */
/* OBSOLETE   if (frame_length < 3)                                  \ */
/* OBSOLETE     for (regnum = A5_REGNUM; regnum < SP_REGNUM; ++regnum)   \ */
/* OBSOLETE       write_register (regnum, read_memory_integer (fp += 4, 4)); \ */
/* OBSOLETE   if (frame_length < 2)                                          \ */
/* OBSOLETE     write_register (SP_REGNUM, read_memory_integer (fp += 4, 4)); \ */
/* OBSOLETE   fp -= 4;                                                  \ */
/* OBSOLETE   if (frame_length < 3)                                     \ */
/* OBSOLETE     for (regnum = S7_REGNUM; regnum < S0_REGNUM; ++regnum) {        \ */
/* OBSOLETE       read_memory (fp += 8, buf, 8);                                \ */
/* OBSOLETE       write_register_bytes (REGISTER_BYTE (regnum), buf, 8);}   \ */
/* OBSOLETE   if (frame_length < 2)     {                                       \ */
/* OBSOLETE     read_memory (fp += 8, buf, 8);                          \ */
/* OBSOLETE     write_register_bytes (REGISTER_BYTE (regnum), buf, 8);}     \ */
/* OBSOLETE   else write_register (SP_REGNUM, fp + 8);                  \ */
/* OBSOLETE   flush_cached_frames ();                                   \ */
/* OBSOLETE } while (0) */
/* OBSOLETE  */
/* OBSOLETE /* This sequence of words is the instructions */
/* OBSOLETE      mov sp,ap */
/* OBSOLETE      pshea 69696969 */
/* OBSOLETE      calls 32323232 */
/* OBSOLETE      bkpt */
/* OBSOLETE    Note this is 16 bytes.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #define CALL_DUMMY {0x50860d4069696969LL,0x2140323232327d50LL} */
/* OBSOLETE  */
/* OBSOLETE #define CALL_DUMMY_LENGTH 16 */
/* OBSOLETE  */
/* OBSOLETE #define CALL_DUMMY_START_OFFSET 0 */
/* OBSOLETE  */
/* OBSOLETE /* Insert the specified number of args and function address */
/* OBSOLETE    into a call sequence of the above form stored at DUMMYNAME.  *x/ */
/* OBSOLETE  */
/* OBSOLETE #define FIX_CALL_DUMMY(dummyname, pc, fun, nargs, args, type, gcc_p)   \ */
/* OBSOLETE { *(int *)((char *) dummyname + 4) = nargs; \ */
/* OBSOLETE   *(int *)((char *) dummyname + 10) = fun; } */
/* OBSOLETE  */
/* OBSOLETE /* Defs to read soff symbol tables, see dbxread.c *x/ */
/* OBSOLETE  */
/* OBSOLETE #define NUMBER_OF_SYMBOLS    ((long) opthdr.o_nsyms) */
/* OBSOLETE #define STRING_TABLE_OFFSET  ((long) filehdr.h_strptr) */
/* OBSOLETE #define SYMBOL_TABLE_OFFSET  ((long) opthdr.o_symptr) */
/* OBSOLETE #define STRING_TABLE_SIZE    ((long) filehdr.h_strsiz) */
/* OBSOLETE #define SIZE_OF_TEXT_SEGMENT ((long) txthdr.s_size) */
/* OBSOLETE #define ENTRY_POINT          ((long) opthdr.o_entry) */
/* OBSOLETE  */
/* OBSOLETE #define READ_STRING_TABLE_SIZE(BUFFER) \ */
/* OBSOLETE     (BUFFER = STRING_TABLE_SIZE) */
/* OBSOLETE  */
/* OBSOLETE #define DECLARE_FILE_HEADERS \ */
/* OBSOLETE   FILEHDR filehdr;                                                  \ */
/* OBSOLETE   OPTHDR opthdr;                                                    \ */
/* OBSOLETE   SCNHDR txthdr */
/* OBSOLETE  */
/* OBSOLETE #define READ_FILE_HEADERS(DESC,NAME) \ */
/* OBSOLETE {                                                                   \ */
/* OBSOLETE   int n;                                                            \ */
/* OBSOLETE   val = myread (DESC, &filehdr, sizeof filehdr);                    \ */
/* OBSOLETE   if (val < 0)                                                              \ */
/* OBSOLETE     perror_with_name (NAME);                                                \ */
/* OBSOLETE   if (! IS_SOFF_MAGIC (filehdr.h_magic))                            \ */
/* OBSOLETE     error ("%s: not an executable file.", NAME);                    \ */
/* OBSOLETE   lseek (DESC, 0L, 0);                                                      \ */
/* OBSOLETE   if (myread (DESC, &filehdr, sizeof filehdr) < 0)                  \ */
/* OBSOLETE     perror_with_name (NAME);                                                \ */
/* OBSOLETE   if (myread (DESC, &opthdr, filehdr.h_opthdr) <= 0)                        \ */
/* OBSOLETE     perror_with_name (NAME);                                                \ */
/* OBSOLETE   for (n = 0; n < filehdr.h_nscns; n++)                                     \ */
/* OBSOLETE     {                                                                       \ */
/* OBSOLETE       if (myread (DESC, &txthdr, sizeof txthdr) < 0)                        \ */
/* OBSOLETE     perror_with_name (NAME);                                        \ */
/* OBSOLETE       if ((txthdr.s_flags & S_TYPMASK) == S_TEXT)                   \ */
/* OBSOLETE     break;                                                          \ */
/* OBSOLETE     }                                                                       \ */
/* OBSOLETE } */
